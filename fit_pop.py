# -*- coding: utf-8 -*-

# FIT-POP v1.0
# The program for fitting specific electronic state population extracted with analyze_pops.sh or analyzeSH.sh and
# calculating the lifetime of the state from fitting parameters

# Created by Jan Polena (2023)

# =====================================================================================================================
# LIBRARIES

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pylab import subplot
from scipy.optimize import curve_fit
import sys
import argparse
from os.path import exists

# =====================================================================================================================
# PARSER SECTION

parser = argparse.ArgumentParser(
    description="-----------------------------------------------------------------------------------------------------"
                "-------\n\n"
                "                                            FIT-POP v1.0 MANUAL                         \n\n"
                "-----------------------------------------------------------------------------------------------------"
                "-------\n\n"
                "The script uses 'populations.dat' file generated by analyze_pops.sh or analyzeSH.sh as input to fit "
                "a target \nstate with an adequate fitting function and calculate its lifetime. The frame-work provides"
                " not only several \nfitting procedures with corresponding statistics, but also user-friendly flags "
                "to mofidy a design of figure.",
    epilog="----------------------------------------------------------------------------------------------------------"
           "--\n"
           "                                    REFERENCES TO FEW FITTING FUNCTIONS                         \n"
           "----------------------------------------------------------------------------------------------------------"
           "--\n\n"
           "JJ Fit:\n"
           "    Janoš, J.; Madea, D.; Mahvidi, S.; Mujawar, T.; Švenda, J.; Suchan, J.; Slavíček, P.; Klán, P.\n"
           "    Conformational Control of the Photodynamics of a Bilirubin Dipyrrinone Subunit: Femtosecond\n"
           "    Spectroscopy Combined with Nonadiabatic Simulations. J. Phys. Chem. A 2020, 124 (50), 10457–10471.\n"
           "Bi-exponential Fit:\n"
           "    Cusati, T.; Granucci, G.; Persico, M. Photodynamics and Time-Resolved Fluorescence of Azobenzene\n"
           "    in Solution: A Mixed Quantum-Classical Simulation. J. Am. Chem. Soc. 2011, 133 (13), 5109–5123.\n"
           "            (I found out there is a mistake in the equation. In the paper, there is a product of two \n"
           "            excited state decay terms. However, there should be a sum instead. In the code, the fit\n"
           "            function is fixed.)\n\n"
           "----------------------------------------------------------------------------------------------------------"
           "--\n"
           "Created by Jan Polena (2023)\n"
           "----------------------------------------------------------------------------------------------------------"
           "--",
    formatter_class=argparse.RawTextHelpFormatter,
    usage='%(prog)s -n NSTATES [options]')

parser.add_argument('-v', '--version', action='version', version='Fit-Pops 1.0',
                    help="show program's version number and exit\n"
                         "------------------------------------------------------------------------------------\n"
                         "                                 FITTING PROCEDURE                                  \n"
                         "------------------------------------------------------------------------------------")

# FITTING PROCEDURE
parser.add_argument('-n', '--nstates', type=int, required=True,
                    help='Number of states (compuslory parameter)')
parser.add_argument('-m', '--spin_multi', default=1, type=int,
                    help='Spin multiplicity of states:\n'
                         '1 - All states are singlets (default)\n'
                         '2 - The ground state is singlet, the excited states are doublets\n'
                         '3 - The ground state is singlet, the excited states are triplets'
                         '4 - All states are doublets'
                         '5 - All states are triplets')
parser.add_argument('-fit', '--fit_type', default=0, type=int,
                    help='Type of a fit function:\n'
                         '0 - No fit (default)\n'
                         '1 - JJ fit\n'
                         '2 - Exponential fit\n'
                         '3 - Bi-exponential fit\n'
                         '4 - Bi-exp. JJ Master fit\n'
                         '          (In specfific cases of Bi-exponential fitting procedures, the bounds \n'
                         '          for decay components may be changed in the code in Fitting section)')
parser.add_argument('-t', '--target', default=1, type=int,
                    help='Target state to be fitted:\n'
                         '0 - Ground state\n'
                         '1 - 1st excited state (default)\n'
                         '2 - 2nd excited state, ...')
parser.add_argument('-d', '--show_details', default=False, action='store_true',
                    help='Print fitting function and lifetimes within the figure')
parser.add_argument('-s', '--show_stats', default=False, action='store_true',
                    help='Print fitting statistics such as parameters standard deviation errors and in cases\n'
                         'of Bi-exponenital fitting procedures also a covariance matrix into the console\n'
                         '------------------------------------------------------------------------------------\n'
                         '                                   FIGURE OPTIONS                                   \n'
                         '------------------------------------------------------------------------------------')

# FIGURE OPTIONS
parser.add_argument('-x', '--x_length', default=0, type=float,
                    help='Length of horizontal axis in femtoseconds')
parser.add_argument('-l', '--fig_linewidth', default=1.8, type=float,
                    help='Linewidth of plots (default = 1.8)')
parser.add_argument('-font', '--fig_fontsize', default=18, type=int,
                    help='Fontsize of labels and text (default = 18)')
parser.add_argument('-size', '--fig_size', default=(16, 9),
                    help='Size of the figure: (4, 3); (8, 6); (16, 9) (default); ...\n'
                         '------------------------------------------------------------------------------------\n'
                         '                                 PRINTING THE FIGURE                                \n'
                         '------------------------------------------------------------------------------------')

# PRINTING THE FIGURE
parser.add_argument('-p', '--print_fig', default=False, action='store_true',
                    help='Print the figure to "output" destination')
parser.add_argument('-dpi', '--fig_dpi', default=300,
                    help='Options: figure, 72 (optimal screen DPI), 300 (default), 1200, ...')
parser.add_argument('-f', '--fig_format', default='png',
                    help='Options: .png (default), .pdf, .svg, ...\n'
                         '------------------------------------------------------------------------------------\n'
                         '                                  PATHS TO THE DATA                                 \n'
                         '------------------------------------------------------------------------------------')

# PATHS TO THE DATA
parser.add_argument('-i', '--input_file', default='populations.dat',
                    help='Path to the data (populations) generated by analyze_pops.sh or analyzeSH.sh\n'
                         '(default = populations.dat)')
parser.add_argument('-o', '--output_file', default='fitted_pop',
                    help='Path to a printed figure (suffix of the file is set automatically by -f flag)\n'
                         '(default = fitted_pop)')

# STORING PARSER ARGUMENTS INTO A "CONFIG" OBJECT
args = parser.parse_args()
config = vars(args)

# =====================================================================================================================
# LOADING VARIABLES

# FITTING PROCEDURE
nstates = config['nstates']
spin_multi = config['spin_multi']
fit_type = config['fit_type']
fit_state = config['target']
show_statistics = config['show_stats']

# FIGURE OPTIONS
show_details = config['show_details']
fig_linewidth = config['fig_linewidth']
fig_fontsize = config['fig_fontsize']
fig_size = config['fig_size']
x_length = config['x_length']

# PRINTING THE FIGURE
print_fig = config['print_fig']
fig_dpi = config['fig_dpi']
fig_format = config['fig_format']

# PATH TO THE DATA
data = config['input_file']
output = config['output_file']

# =====================================================================================================================
# ERROR CHECKS

if not exists(data):
    sys.exit("\n%s does not exist.\n" % data)

while spin_multi not in (1, 2, 3, 4, 5):
    sys.exit("\nPlease, choose a propriate spin multiplicity in the head of the code:\n"
             "1 - All states are singlets\n"
             "2 - The ground state is singlet, the excited states are doublets\n"
             "3 - The ground state is singlet, the excited states are triplets\n"
             "4 - All states are doublets\n"
             "5 - All states are triplets\n")

while fit_type not in (0, 1, 2, 3, 4):
    sys.exit("\nPlease, choose a propriate type of a fit function in the head of the code:\n"
             "0 - No fit\n"
             "1 - JJ fit\n"
             "2 - Exponential\n"
             "3 - Bi-exponential fit\n"
             "4 - Bi-exponential fit (JJ Master fit)\n")

if nstates < 1:
    sys.exit("\nPlease, choose a positive number of states in the head of the code.\n")

if show_details and fit_type == 0:
    sys.exit("\nYou chose not to fit the data, and yet, you would like to show the details of a fitting procedure. "
             "Please, refrain from this behaviour.\n")

if show_statistics and fit_type == 0:
    sys.exit("\nYou chose not to fit the data, and yet, you would like to show the stadard deviation error of fitted "
             "parameters. Please, refrain from this behaviour.\n")

# =====================================================================================================================
# DATA FETCH

pops = np.transpose(np.loadtxt(data))
state = [[] for i in range(nstates)]
nstep = int(pops.size / len(pops) / nstates)  # Determining number of steps in the simulation

for j in range(nstates):
    state[j] = pops[:, j * nstep: (j + 1) * nstep]

t = state[0][0]

# =====================================================================================================================
# PLOTTING THE DATA

plt.figure(figsize=fig_size)
ax = subplot(111)

if spin_multi == 1:
    for k in range(nstates):
        ax.plot(state[k][0], state[k][1], label="$\mathregular{S_%d}$" % k, linewidth=fig_linewidth, color='C%d' % k)
        ax.fill_between(state[k][0], state[k][1] + state[k][2], state[k][1] - state[k][2], alpha=0.2, color='C%d' % k)
elif spin_multi == 2:
    ax.plot(state[0][0], state[0][1], label="$\mathregular{S_0}$", linewidth=fig_linewidth, color='C0')
    ax.fill_between(state[0][0], state[0][1] + state[0][2], state[0][1] - state[0][2], alpha=0.2, color='C0')
    for k in range(1, nstates):
        ax.plot(state[k][0], state[k][1], label="$\mathregular{D_%d}$" % k, linewidth=fig_linewidth, color='C%d' % k)
        ax.fill_between(state[k][0], state[k][1] + state[k][2], state[k][1] - state[k][2], alpha=0.2, color='C%d' % k)
elif spin_multi == 3:
    ax.plot(state[0][0], state[0][1], label="$\mathregular{S_0}$", linewidth=fig_linewidth, color='C0')
    ax.fill_between(state[0][0], state[0][1] + state[0][2], state[0][1] - state[0][2], alpha=0.2, color='C0')
    for k in range(1, nstates):
        ax.plot(state[k][0], state[k][1], label="$\mathregular{T_%d}$" % k, linewidth=fig_linewidth, color='C%d' % k)
        ax.fill_between(state[k][0], state[k][1] + state[k][2], state[k][1] - state[k][2], alpha=0.2, color='C%d' % k)
elif spin_multi == 4:
    for k in range(nstates):
        ax.plot(state[k][0], state[k][1], label="$\mathregular{D_%d}$" % k, linewidth=fig_linewidth, color='C%d' % k)
        ax.fill_between(state[k][0], state[k][1] + state[k][2], state[k][1] - state[k][2], alpha=0.2, color='C%d' % k)
elif spin_multi == 5:
    for k in range(nstates):
        ax.plot(state[k][0], state[k][1], label="$\mathregular{T_%d}$" % k, linewidth=fig_linewidth, color='C%d' % k)
        ax.fill_between(state[k][0], state[k][1] + state[k][2], state[k][1] - state[k][2], alpha=0.2, color='C%d' % k)

# =====================================================================================================================
# FITTING SECTION

if fit_type == 0:
    fit_msg = "No fit type was set."

# JJ FIT
elif fit_type == 1:
    def objective(t, t0, tau):
        return np.piecewise(t, [((t >= 0) & (t <= t0)), t > t0], [1, lambda t: np.exp(-(t - t0) / tau)])


    fit, cov = curve_fit(objective, t, state[fit_state][1], bounds=((0, 0), (np.inf, np.inf)), absolute_sigma=True)
    t0, tau = fit
    t0 = int(t0)
    tau = int(tau)
    total = t0 + tau
    fit_msg = 'Vibrational relaxation = %d fs\nExcited state lifetime = %d fs\nTotal decay time = %d fs' \
              % (t0, tau, total)
    x_line = np.arange(min(t), max(t), 1)
    y_line = objective(x_line, t0, tau)
    if spin_multi == 1 or fit_state == 0:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{S_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 2 or spin_multi == 4:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{D_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 3 or spin_multi == 5:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{T_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)

    fit_info = (r'$\bf{Fit}$ $\bf{details:}$''\n\n'
                r'$t \leq t_0:$ $f(x)=1$''\n'
                r'$t > t_0:$ $f(x)=e^{\frac{-(t-t_0)}{\tau}}$''\n\n'
                r'$t_0 = %d$ fs''\n'r'$\tau = %d$ fs''\n'r'$\tau_\mathrm{total} = %d$ fs' % (t0, tau, total))

# EXPONENTIAL FIT
elif fit_type == 2:
    def objective(t, tau):
        return np.exp(-t / tau)


    fit, cov = curve_fit(objective, t, state[fit_state][1], bounds=(0, np.inf), absolute_sigma=True)
    tau = fit
    fit_msg = 'Excited state lifetime = %d fs' % tau
    x_line = np.arange(min(t), max(t), 1)
    y_line = objective(x_line, tau)
    if spin_multi == 1 or fit_state == 0:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{S_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 2 or spin_multi == 4:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{D_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 3 or spin_multi == 5:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{T_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    fit_info = (r'$\bf{Fit}$ $\bf{details:}$''\n'
                r'$f(x)=e^{\frac{-t}{\tau}}$''\n\n'
                r'$\tau = %d$ fs' % tau)

# BI-EXPONENTIAL FIT 
elif fit_type == 3:
    def objective(t, t0, tau1, tau2, w):
        return np.piecewise(t, [((t >= 0) & (t <= t0)), (t > t0)],
                            [1, lambda t: w * np.exp(-(t - t0) / tau1) + (1 - w) * np.exp(-(t - t0) / tau2)])


    fit, cov = curve_fit(objective, t, state[fit_state][1], maxfev=100000, absolute_sigma=True,
                         bounds=((0, 0, 0, 0), (np.inf, np.inf, np.inf, 1.0)))
    t0, tau1, tau2, w = fit
    fit_msg = 'Vibrational relaxation = %d fs\n1st excited state lifetime component = %d fs\n2nd excited state ' \
              'lifetime component = %d fs\nWeight of 1st component = %1.3f\nWeight of 2nd component = %1.3f' \
              % (t0, tau1, tau2, w, 1 - w)
    x_line = np.arange(min(t), max(t), 1)
    y_line = objective(x_line, t0, tau1, tau2, w)
    if spin_multi == 1 or fit_state == 0:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{S_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 2 or spin_multi == 4:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{D_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 3 or spin_multi == 5:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{T_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    fit_info = (r'$\bf{Fit}$ $\bf{details:}$''\n\n'
                r'$t \leq t_0:$ $f(x)=1$''\n'
                r'$t > t_0:$ $f(x)=W\cdot e^{\frac{-(t-t_0)}{\tau_1}} +(1-W)\cdot e^{\frac{-(t-t_0)}{\tau_2}}$''\n\n'
                r'$t_0 = %d$ fs''\n'r'$\tau_1 = %d$ fs''\n'r'$\tau_2 = %d$ fs''\n'r'$W = %1.3f$' % (t0, tau1, tau2, w))

# BI-EXPONENTIAL FIT – JJ MASTER FIT
elif fit_type == 4:
    def objective(t, a, b, c):
        return np.piecewise(t, [((t >= 0) & (t <= a)), (t > a)],
                            [lambda t: np.exp(-t / b), lambda t: (np.exp(-a / b)) * np.exp(-(t - a) / c)])


    fit, cov = curve_fit(objective, t, state[fit_state][1], maxfev=100000, absolute_sigma=True,
                         bounds=((0, 0, 0), (np.inf, np.inf, np.inf)))
    a, b, c = fit
    fit_msg = 'b-parameter = %d fs\nThe 1st decay component of exponenital tail = %d fs\nThe 2nd decay component of ' \
              'exponenital tail = %d fs' % (b, a, c)
    x_line = np.arange(min(t), max(t), 1)
    y_line = objective(x_line, a, b, c)
    if spin_multi == 1 or fit_state == 0:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{S_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 2 or spin_multi == 4:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{D_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    elif spin_multi == 3 or spin_multi == 5:
        plt.plot(x_line, y_line, '--', label='fit – $\mathregular{T_%d}$' % fit_state, color='black',
                 linewidth=fig_linewidth)
    fit_info = (r'$\bf{Fit}$ $\bf{details:}$''\n\n'
                r'$t \leq t_0:$ $f(x)=e^{\frac{-t}{b}}$''\n'
                r'$t \leq t_0:$ $f(x)=e^{\frac{-a}{b}}\cdot e^{\frac{-(t-a)}{c}}$''\n\n'
                r'$a = %d$ fs''\n'r'$b = %d$ fs''\n'r'$c = %d$ fs' % (a, b, c))

# =====================================================================================================================
# STATISTICS
if show_statistics:
    param_err = np.sqrt(np.diag(cov))

    if fit_type == 1:
        sigma_total = float(np.sum(cov))
        stats_msg = "s(t0) = %d fs\n" \
                    "s(tau) = %d fs\n" \
                    "s(total_decay) = %d fs" \
                    % (param_err[0], param_err[1], sigma_total)

    elif fit_type == 2:
        stats_msg = "s(tau) = %d fs" % param_err[0]

    elif fit_type == 3:
        stats_msg = "s(t0) = %d fs\n" \
                    "s(tau1) = %d fs\n" \
                    "s(tau2) = %d fs\n" \
                    "s(weight) = %1.3f" \
                    % (param_err[0], param_err[1], param_err[2], param_err[3])

    elif fit_type == 4:
        stats_msg = "s(a) = %d fs\n" \
                    "s(b) = %d fs\n" \
                    "s(c) = %d fs" \
                    % (param_err[0], param_err[1], param_err[2])

# =====================================================================================================================
# FIGURE CONSTRUCTION

ax.set_xlabel("Time / fs", fontsize=fig_fontsize)
ax.set_ylabel("Population", fontsize=fig_fontsize)
ax.tick_params(axis='x', labelsize=fig_fontsize)
ax.tick_params(axis='y', labelsize=fig_fontsize)
ax.legend(prop={"size": fig_fontsize}, loc=7)
for axis in ['top', 'bottom', 'left', 'right']:
    ax.spines[axis].set_linewidth(fig_linewidth)
ax.set_ylim([0, 1.01])
if x_length != 0:
    ax.set_xlim([0, x_length])
else:
    x_length_full = t[nstep - 1]
    ax.set_xlim([0, x_length_full])

if show_details:
    props = dict(boxstyle='round', facecolor='white', alpha=0.5)
    ax.text(0.5, 0.5, fit_info, transform=ax.transAxes, fontsize=fig_fontsize, verticalalignment='center', bbox=props)

# =====================================================================================================================
# PRINTING THE OUTPUT AND THE FIGURE

# THE CONSOLE OUTPUT
print("\n----------------------------------------------------------\n\n"
      "                        FIT-POP v1.0\n\n"
      "----------------------------------------------------------\n")

if fit_type != 0:
    print("LIFETIMES:")
print(fit_msg)

if show_statistics:
    print("\nSTATISTICS:")
    print("Parameters' standard deviation errors:")
    print(stats_msg)
    if fit_type == 3 or fit_type == 4:
        print("\nCovariance matrix:\n", cov)

print("\n----------------------------------------------------------\n")
print("Thank you for using Fit-Pop! God loves you.\n")

# DISPLAYING AND SAVING THE FIGURE
if print_fig:
    plt.savefig("%s.%s" % (output, fig_format), format=fig_format, dpi=fig_dpi)

plt.tight_layout()
plt.show()
